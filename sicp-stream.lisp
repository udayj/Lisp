(defun memo-proc (proc)
  (let ((already-run? nil)
	(result nil))
    (lambda ()
      (if (not already-run?)
	  (progn
	    (setf result (funcall proc))
	    (setf already-run? t)
	    result)
	  result))))
(defmacro delay (expr)
  `(memo-proc (lambda () ,expr)))
(defmacro cons-stream (a b)
  `(cons ,a (delay ,b)))
(defun force (delayed-object)
  (funcall delayed-object))
(defun stream-car (s)
  (car s))
(defun stream-cdr (s)
  (force (cdr s)))
(defun stream-cadr (s)
	(stream-car (stream-cdr s)))
(defun enumerate-interval (low high)
  (if (> low high)
      nil
      (cons-stream low (enumerate-interval (+ low 1) high))))
(defun show (x)
  (format t "~a~%" x)
  x)
(defun stream-map (proc s)
  (if (equalp nil s) nil
      (cons-stream (funcall proc (stream-car s)) (stream-map proc (stream-cdr s)))))
(defun stream-ref (s n)
  (if (= 0 n) (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))
(defun stream-filter (pred stream)
  (cond ((equalp nil stream) nil)
	((funcall pred (stream-car stream))
	 (cons-stream (stream-car stream) (stream-filter pred (stream-cdr stream))))
	(t (stream-filter pred (stream-cdr stream)))))
(defun accum (x)
  (setf sum (+ sum x))
  sum)
(defun integers-starting-from (n)
  (cons-stream n (integers-starting-from (+ n 1))))
(defun sieve (stream)
  (cons-stream (stream-car stream)
	       (sieve (stream-filter (lambda (x) (not (= 0 (mod x (stream-car stream))))) (stream-cdr stream)))))
(defun stream-map1 (proc &rest argstreams)
  (if (equalp nil (car argstreams))
    nil
    (cons-stream
      (apply proc (mapcar #'stream-car argstreams))
      (apply #'stream-map1
        (cons proc (mapcar #'stream-cdr argstreams))))))
(defun add-stream (s1 s2)
  (stream-map1 #'+ s1 s2))
(defun mul-stream (s1 s2)
  (stream-map1 #'* s1 s2))
(defun partial-sums (s)
  (progn 
    (setf result
	 (cons-stream (stream-car s) (add-stream result (stream-cdr s))))
    result))
(defun partial-sums1 (s)
  (cons-stream (stream-car s) (add-stream (stream-cdr s) (partial-sums1 s))))
(defun scale-stream (stream factor)
  (stream-map1 (lambda (x) (* x factor)) stream))
(defun merge1 (s1 s2)
  (cond ((equalp nil s1) s2)
	((equalp nil s2) s1)
	(t
	 (let ((s1car (stream-car s1))
	       (s2car (stream-car s2)))
	   (cond ((< s1car s2car) (cons-stream s1car (merge1 (stream-cdr s1) s2)))
		 ((> s1car s2car) (cons-stream s2car (merge1 s1 (stream-cdr s2))))
		 (t (cons-stream s1car (merge1 (stream-cdr s1) (stream-cdr s2)))))))))
(defun integrate-series (s)
  (stream-map1 #'/ s (integers-starting-from 1)))
(defun neg-series (s)
  (stream-map (lambda (x) (- 0 x)) s))
(defun mul-series (s1 s2)
  (cons-stream (* (stream-car s1) (stream-car s2)) (add-stream (scale-stream (stream-cdr s2) (stream-car s1)) (mul-series (stream-cdr s1) s2))))
(defun invert-unit-series (s)
  (cons-stream 1 (neg-series (mul-series (stream-cdr s) (invert-unit-series s)))))
(defun div-series (s1 s2)
  (mul-series s1 (invert-unit-series s2)))
(defun average (x y)
  (/ (+ x y) 2))
(defun sqrt-improve (guess x)
  (average guess (/ x guess)))
(defun sqrt-stream (x)
  (progn 
    (setf guesses
	  (cons-stream 1.0 (stream-map1 (lambda (guess) (sqrt-improve guess x)) guesses)))
    guesses))
(defun pi-summands (n)
  (cons-stream (/ 1.0 n) (neg-series (pi-summands (+ n 2)))))
(defun euler-transform (s)
  (let ((s0 (stream-ref s 0))
	(s1 (stream-ref s 1))
	(s2 (stream-ref s 2)))
    (cons-stream (- s2 (/ (square (- s2 s1)) (+ s0 (* -2 s1) s2)))
		 (euler-transform (stream-cdr s)))))
(defun square (x)
  (* x x))
(defun make-tableau (transform s)
  (cons-stream s (make-tableau transform (funcall transform s))))
(defun accelerated-sequence (transform s)
  (stream-map1 #'stream-car (make-tableau transform s)))
(defun interleave (s1 s2)
  (if (equalp nil s1) s2
      (cons-stream (stream-car s1) (interleave s2 (stream-cdr s1)))))
(defun pairs1 (s t1)
  (cons-stream (list (stream-car s) (stream-car t1))
	       (interleave (stream-map1 (lambda (x) (list (stream-car s) x)) (stream-cdr t1)) 
			   (pairs1 (stream-cdr s) (stream-cdr t1)))))
(defun display-stream (stream n)
  (if (= 0 n) nil
      (progn 
      (show (stream-car stream))
      (display-stream (stream-cdr stream) (- n 1)))))
(defun triples (s1 t1 u1)
  (cons-stream (list (stream-car s1) (stream-car t1) (stream-car u1))
	       (interleave (stream-map1 (lambda (x) (cons (stream-car s1) x)) (stream-cdr (pairs1 t1 u1)))
			   (triples (stream-cdr s1) (stream-cdr t1) (stream-cdr u1)))))
(defun pythagorean-filter (x)
  (let ((i (car x))
	(j (cadr x))
	(k (caddr x)))
    (= (+ (square i) (square j)) (square k))))
(defun merge-weighted (s1 s2 weight)
  (cond ((equalp nil s1) s2)
	((equalp nil s2) s1)
	(t
	 (let ((w1 (funcall weight (stream-car s1)))
	       (w2 (funcall weight (stream-car s2)))
	       (s1car (stream-car s1))
	       (s2car (stream-car s2)))
	   (cond ((< w1 w2) (cons-stream s1car (merge-weighted (stream-cdr s1) s2 weight)))
		 ((> w1 w2) (cons-stream s2car (merge-weighted s1 (stream-cdr s2) weight)))
		 (t (cons-stream s1car (cons-stream s2car (merge-weighted (stream-cdr s1) (stream-cdr s2) weight)))))))))
(defun weighted-pairs (s t1 weight)
  (cons-stream (list (stream-car s) (stream-car t1))
	       (merge-weighted (stream-map1 (lambda (x) (list (stream-car s) x)) (stream-cdr t1)) 
			   (weighted-pairs (stream-cdr s) (stream-cdr t1) weight) weight)))
(defun weight-sum (x)
  (+ (car x) (cadr x)))
(defun weight-sum-cube (x)
  (+ (cube (car x)) (cube (cadr x))))
(defun cube (x)
  (* x x x))
(defun ramanujan-stream (x)
  (let ((w1 (weight-sum-cube (stream-car x)))
	(w2 (weight-sum-cube (stream-car (stream-cdr x)))))
    (cond ((= w1 w2) (cons-stream w1 (ramanujan-stream (stream-cdr x))))
	  (t (ramanujan-stream (stream-cdr x))))))
(defun sum-square (x)
  (let ((w1 (sumsq (stream-car x)))
	(w2 (sumsq (stream-car (stream-cdr x))))
	(w3 (sumsq (stream-car (stream-cdr (stream-cdr x))))))
    (if (= w1 w2 w3) (cons-stream (list w1 (stream-car x) (stream-car (stream-cdr x)) (stream-car (stream-cdr (stream-cdr x))))
				  (sum-square (stream-cdr x)))
	(sum-square (stream-cdr x)))))
(defun sumsq (x)
  (+ (square (car x)) (square (cadr x))))
(defun integral (integrand initial-value dt)
  (progn
    (setf int (cons-stream initial-value (add-stream (scale-stream integrand dt) int)))
    int))
(defun rc (r c dt)
  (lambda (i v0)
    (progn 
      (add-stream (scale-stream i r) (integral (scale-stream i (/ 1 c)) v0 dt)))))
