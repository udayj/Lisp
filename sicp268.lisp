(defun make-leaf (symbol weight)
  (list 'leaf symbol weight))
(defun leaf? (object)
  (equalp 'leaf (car object)))
(defun symbol-leaf (leaf)
  (cadr leaf))
(defun weight-leaf (leaf)
  (caddr leaf))
(defun make-code-tree (left right)
  (list left right (append (symbols left) (symbols right)) (+ (weight left) (weight right))))
(defun left-branch (tree)
  (car tree))
(defun right-branch (tree)
  (cadr tree))
(defun symbols (tree)
  (if (leaf? tree) (list (symbol-leaf tree))
      (caddr tree)))
(defun weight (tree)
  (if (leaf? tree) (weight-leaf tree)
      (cadddr tree)))
(defun adjoin-set-huffman (x set)
  (cond ((nil? set) (list x))
	((< (weight x) (weight (car set))) (cons x set))
	(t (cons (car set) (adjoin-set-huffman x (cdr set))))))
(defun make-leaf-set (pairs)
  (if (nil? pairs) nil
      (let ((pair (car pairs)))
	(adjoin-set-huffman (make-leaf (car pair) (cadr pair)) (make-leaf-set (cdr pairs))))))
(defun encode (message tree)
  (if (nil? message) nil
      (append (encode-symbol (car message) tree) (encode (cdr message) tree))))
(defun present-in-symbols? (symbol symbol-list)
  (cond ((nil? symbol-list) nil)
	((equalp symbol (car symbol-list)) t)
	(t (present-in-symbols? symbol (cdr symbol-list)))))
(defun encode-symbol (symbol tree)
  (cond ((leaf? tree) nil)
	((present-in-symbols? symbol (symbols (left-branch tree))) (cons 0 (encode-symbol symbol (left-branch tree))))
	(t (cons 1 (encode-symbol symbol (right-branch tree))))))
(defun make-huffman-tree (pairs)
  (successive-merge (make-leaf-set pairs)))
(defun successive-merge (leaf-set)
  (if (= 1 (length leaf-set)) (car leaf-set)
      (let ((set1 (car leaf-set))
	    (set2 (cadr leaf-set)))
	(successive-merge (adjoin-set-huffman (make-code-tree set1 set2) (cddr leaf-set))))))

  